<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Talsu kauss — Tabulas</title>

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css">
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>

  <style>
    /* Header */
    .custom-header {
      background-color: #027669 !important;
      color: #ffffff !important;
      text-align: center;
      vertical-align: middle;
    }

    /* Wrapper to center tables */
    .table-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 2rem;
      margin-top: 1.5rem;
    }

    /* Make all tables share the same total width and fixed layout
       so column widths are identical across days */
    .fixed-table {
      table-layout: fixed;      /* equal distribution across columns */
      width: 90%;
      max-width: 1100px;
      margin: 0 auto;
      border-collapse: separate;
    }

    /* Ensure text wraps inside fixed columns */
    .fixed-table th,
    .fixed-table td {
      white-space: normal;
      word-break: break-word;
      padding: 6px 8px;
      text-align: center;
      vertical-align: middle;
    }

    /* Give a little emphasis to the table day heading */
    .table-day-title {
      margin-top: 8px;
      margin-bottom: 2px;
      font-weight: 600;
    }

    /* Group colors */
    .group-2012 td { background-color: #6debd6 !important; }
    .group-2014 td { background-color: #6dc1eb !important; }

    /* Make links not overflow awkwardly */
    .fixed-table a { word-break: break-all; text-decoration: underline; }

    /* Small screens: reduce padding */
    @media (max-width: 576px) {
      .fixed-table th, .fixed-table td { padding: 4px 6px; font-size: 13px; }
    }
    .custom-navbar {
    background-color: #027669 !important;
    color: white !important;
    padding-top: 1px !important;
}

.custom-navbar .navbar-brand {
    color: white !important;
    margin-right: 30px !important;
    font-family: 'Georgia', serif;
}

.custom-navbar .navbar-nav .nav-link {
    color: #E4312A !important;
    font-weight: bold;
}

.custom-navbar .navbar-nav .nav-link:hover {
    color: #f8f9fa !important;
    font-weight: bold;
}
  </style>
</head>
<body class="bg-light">
  <nav class="navbar navbar-expand-lg navbar-dark custom-navbar">
    <div class="container">
      <img src="https://raw.githubusercontent.com/BkTalsi/TalsuKauss2025/main/talsu%20novads2.jpg" alt="Logo" class="navbar-logo" style="height: 40px; margin-right: 8px;">
      <a class="navbar-brand" href="index.html">Talsi Cup 2025</a>
      <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
        <span class="navbar-toggler-icon"></span>
      </button>
      <div class="collapse navbar-collapse" id="navbarNav">
        <ul class="navbar-nav">
          <li class="nav-item"><a class="nav-link" href="index.html">Schedule</a></li>
          <li class="nav-item"><a class="nav-link" href="Tabulas.html">Standings</a></li>
          <li class="nav-item"><a class="nav-link" href="PlayOffs.html">PlayOffs</a></li>
        </ul>
      </div>
    </div>
  </nav>

  <div class="container mt-5">
    <h2 class="text-center">Schedule</h2>
    <!-- Tables will be injected here -->
    <div id="table-container" class="table-container"></div>
  </div>

  <script>
    // Google Sheets info
    const sheetID = "1xXFGcFXoiVo6HYt7o4HDaRbhs5Q8v8mh4iVHKn5zBLQ";
    const gid = "187862000";
    // We SELECT B (date) so we can group, and C,D,E,H,I,M (M contains URL).
    const query = encodeURIComponent("select B,C,D,E,H,I,M,N");
    const apiURL = `https://docs.google.com/spreadsheets/d/${sheetID}/gviz/tq?tqx=out:json&gid=${gid}&tq=${query}`;

    // Extract JSON from Google response wrapper
    function extractJson(text) {
      const m = text.match(/\{[\s\S]*\}/);
      return m ? JSON.parse(m[0]) : null;
    }

    // Convert Google Sheets Date(...) format to "hh:mm" (used for time cells)
    function extractTimeFromDate(dateString) {
      const match = dateString.match(/Date\((\d+),(\d+),(\d+),(\d+),(\d+)\)/);
      if (!match) return dateString;
      const hours = parseInt(match[4], 10);
      const minutes = String(match[5]).padStart(2, "0");
      return `${hours}:${minutes}`;
    }

    // Format a single cell, given the original row object and original column index
    function formatCell(cell, rowObj, originalColIndex) {
      if (!cell || cell.v === undefined) return "";
      // If Google provides formatted text, use it
      if (cell.f) return cell.f;

      // If cell stores a Date(...) string (e.g. time) return hh:mm
      if (typeof cell.v === "string" && cell.v.startsWith("Date(")) {
        return extractTimeFromDate(cell.v);
      }

      // If this is column I (original index 5) — make it linkable to column M (original index 6)
      // (we assume column M contains the URL)
      if (originalColIndex === 5) {
        const urlCell = rowObj.c[6];
        if (urlCell && urlCell.v) {
          // Escape cell.v for HTML — naive approach (works for your content)
          const text = cell.v;
          const href = urlCell.v;
          return `<a href="${href}" target="_blank" rel="noopener noreferrer">${text}</a>`;
        }
      }

      return cell.v;
    }

    async function fetchData() {
      try {
        const res = await fetch(apiURL);
        const txt = await res.text();
        const data = extractJson(txt);
        if (!data) {
          console.error("No JSON returned from Google Sheets.");
          return;
        }

        // Original columns (in the order we requested): B(0),C(1),D(2),E(3),H(4),I(5),M(6)
        // We will DISPLAY columns C,D,E,H,I -> original indices [1,2,3,4,5]
        const displayColIndices = [1,2,3,4,5,"youtube"];

        // Build displayed headers (exclude date (0) and url column (6))
        const headersDisplayed = data.table.cols
          .filter((_, idx) => idx !== 0 && idx !== 6 && idx !== 7)
          .map(col => col.label || "");
        headersDisplayed.push("Video");
        
        // Find original column index for "Grupa" (case-insensitive) so we can color rows accurately.
        // If not found, group coloring will fall back to checking the displayed cells.
        const groupOriginalIdx = data.table.cols.findIndex(col => {
          if (!col.label) return false;
          return /grupa/i.test(col.label);
        });

        // Group rows by date while preserving original order — use Map to keep insertion order
        const grouped = new Map();
        data.table.rows.forEach((rowObj, rowIndex) => {
          // rowObj.c is array of cell objects in the same order as the columns requested.
          const dateCell = rowObj.c && rowObj.c[0];
          if (!dateCell) return; // skip rows with no date
          const dateKey = (dateCell.f || dateCell.v || "").toString();
          if (!grouped.has(dateKey)) grouped.set(dateKey, []);
          grouped.get(dateKey).push({ rowObj, rowIndex });
        });

        // Render tables for each date in insertion order
        let html = "";
        grouped.forEach((rows, dateKey) => {
          html += `<h4 class="text-center table-day-title">${dateKey}</h4>`;
          html += `<table class="table table-bordered table-hover table-sm fixed-table">`;
          html += `<thead><tr>`;
          headersDisplayed.forEach(h => {
            html += `<th class="custom-header">${h}</th>`;
          });
          html += `</tr></thead><tbody>`;

          rows.forEach(({ rowObj, rowIndex }) => {
            // Determine group value from the original group column if found,
            // otherwise try to detect it among displayed columns
            let groupValue = "";
            if (groupOriginalIdx >= 0) {
              const gcell = rowObj.c[groupOriginalIdx];
              groupValue = (gcell && (gcell.f || gcell.v)) ? String(gcell.f || gcell.v).trim() : "";
            } else {
              // fallback: search displayed columns for a cell containing "2012" or "2014"
              for (const colIdx of displayColIndices) {
                const c = rowObj.c[colIdx];
                const txt = (c && (c.f || c.v)) ? String(c.f || c.v) : "";
                if (/2012/.test(txt)) { groupValue = txt; break; }
                if (/2014/.test(txt)) { groupValue = txt; break; }
              }
            }

            // Normalize for matching
            const g = (groupValue || "").toString();

            // Choose row class by group
            let rowClass = "";
            if (/2012/.test(g)) rowClass = "group-2012";
            else if (/2014/.test(g)) rowClass = "group-2014";

            html += `<tr class="${rowClass}">`;
            // Render only the displayed columns (C,D,E,H,I)
            displayColIndices.forEach(origIdx => {
              if (origIdx === "youtube") {
                const ytCell = rowObj.c[7]; // column N
                const link = ytCell && ytCell.v ? String(ytCell.v).trim() : "";
              
                if (link) {
                  html += `<td>
                    <a href="${link}" target="_blank" rel="noopener noreferrer">
                      <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24"
                           viewBox="0 0 24 24" fill="red">
                        <path d="M23.498 6.186a2.993 2.993 0 0 0-2.112-2.12C19.505 3.5 
                                 12 3.5 12 3.5s-7.505 0-9.386.566a2.993 2.993 0 0 0-2.112 
                                 2.12A31.24 31.24 0 0 0 .5 12a31.24 31.24 0 0 0 .002 
                                 5.814 2.993 2.993 0 0 0 2.112 2.12C4.495 20.5 12 
                                 20.5 12 20.5s7.505 0 9.386-.566a2.993 2.993 0 0 0 
                                 2.112-2.12A31.24 31.24 0 0 0 23.5 12a31.24 31.24 
                                 0 0 0-.002-5.814zM9.75 15.02V8.98L15.5 12l-5.75 
                                 3.02z"/>
                      </svg>
                    </a>
                  </td>`;
                } else {
                  html += "<td></td>"; // really empty if no link
                }
              } else {
                const cell = rowObj.c[origIdx];
                const content = formatCell(cell, rowObj, origIdx);
                html += `<td>${content}</td>`;
              }
            });
            html += `</tr>`;
          });

          html += `</tbody></table>`;
        });

        document.getElementById("table-container").innerHTML = html;
      } catch (err) {
        console.error("Error fetching/parsing sheet:", err);
      }
    }

    // Initial fetch + periodic refresh
    window.onload = fetchData;
    setInterval(fetchData, 10000);
  </script>
</body>
</html>
